//================================================================================
// m2v_dec_eval - MPEG2 逆量子化
// ref: ISO13818-2
// $Id: dequant.c 95 2012-02-05 04:23:51Z shana $
//================================================================================

#include "m2v_dec.h"
#include "dump.h"

int intra_qmat[8][8], nonintra_qmat[8][8];
int custom_qmat[2][64];

const int ZIGZAG_SCAN[2][8][8] = {
	{{ 0,  1,  5,  6, 14, 15, 27, 28 },
	{  2,  4,  7, 13, 16, 26, 29, 42 },
	{  3,  8, 12, 17, 25, 30, 41, 43 },
	{  9, 11, 18, 24, 31, 40, 44, 53 },
	{ 10, 19, 23, 32, 39, 45, 52, 54 },
	{ 20, 22, 33, 38, 46, 51, 55, 60 },
	{ 21, 34, 37, 47, 50, 56, 59, 61 },
	{ 35, 36, 48, 49, 57, 58, 62, 63 }},
	{{ 0,  4,  6, 20, 22, 36, 38, 52 },
	{  1,  5,  7, 21, 23, 37, 39, 53 },
	{  2,  8, 19, 24, 34, 40, 50, 54 },
	{  3,  9, 18, 25, 35, 41, 51, 55 },
	{ 10, 17, 26, 30, 42, 46, 56, 60 },
	{ 11, 16, 27, 31, 43, 47, 57, 61 },
	{ 12, 15, 28, 32, 44, 48, 58, 62 },
	{ 13, 14, 29, 33, 45, 49, 59, 63 }},
};

const int DEF_INTRA_QMAT[8][8] = {
	{  8, 16, 19, 22, 26, 27, 29, 34 },
	{ 16, 16, 22, 24, 27, 29, 34, 37 },
	{ 19, 22, 26, 27, 29, 34, 34, 38 },
	{ 22, 22, 26, 27, 29, 34, 37, 40 },
	{ 22, 26, 27, 29, 32, 35, 40, 48 },
	{ 26, 27, 29, 32, 35, 40, 48, 58 },
	{ 26, 27, 29, 34, 38, 46, 56, 69 },
	{ 27, 29, 35, 38, 46, 56, 69, 83 },
};

static const int INTRA_DC_MULT[4] = {8, 4, 2, 1};
static const int QUANT_SCALE[2][32] = {
{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62},
{0,1,2,3,4,5,6,7,8,10,12,14,16,18,20,22,24,28,32,36,40,44,48,52,56,64,72,80,88,96,104,112}};

////////////////////////////////////////////////////////////////////////////////
/// @brief 逆スキャンを行う (小ブロック単位)
///
/// 実装時の都合上、dq に含めている。
///
int invscan(int qfs[64], int qf[8][8])
{
	dump_header(dump_is);

	for(int v = 0; v < 8; ++v) for(int u = 0; u < 8; ++u)
	{
		qf[v][u] = qfs[ZIGZAG_SCAN[alt_scan][v][u]];
		dumpf(dump_is, " %5d%s", qf[v][u], u == 7 ? "\n" : "");
	}

	return 1;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief 逆量子化を行う (小ブロック単位)
///
/// @param qf 量子化された係数列
/// @param lf 出力係数列
///
int dequant(int qf[8][8], int lf[8][8])
{
	// F[v][u] = ((2×QF[v][u]+k)×W[w][v][u]×quant_scale)/32
	// where: k = 0              (intra)
	//            sign(QF[v][u]) (non-intra)

	int qs = QUANT_SCALE[q_scale_type][mb_q_scale_code];

	if(mb_intra)
	{
		// intra

		// DC は定数乗算のみ
		lf[0][0] = qf[0][0] * INTRA_DC_MULT[intra_dc_precision];

		// DC 以外
		for(int i = 1; i < 64; ++i)
			lf[0][i] = (2 * qf[0][i]) * intra_qmat[0][i] * qs / 32;
	}
	else
	{
		// non intra
		for(int i = 0; i < 64; ++i)
		{
			int x = 2 * qf[0][i];
			if(x < 0) --x;
			if(x > 0) ++x;
			lf[0][i] = x * nonintra_qmat[0][i] * qs / 32;
		}
	}

	dump_header(dump_dq);

	int mm = 0;

	// クリッピングとミスマッチ対策
	for(int i = 0; i < 64; ++i)
	{
		int j = lf[0][i];
		if(j < -2048)
			lf[0][i] = -2048;	// -2048 は最下位ビット 0 なので mm^= 不要
		else if(j > 2047)
			mm ^= (lf[0][i] = 2047);
		else
			mm ^= j;

		if(i == 63 && !(mm & 1)) lf[0][i] ^= 1;
		dumpf(dump_dq, " %5d%s", lf[0][i], (i & 7) == 7 ? "\n" : "");
		dumpf(dump_isdq, "%5d%s", lf[0][i], (i & 7) == 7 ? "\n" : "");
	}

	return 1;
}


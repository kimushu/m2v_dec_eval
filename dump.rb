#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
#================================================================================
# dump.c dump.h 生成スクリプト
# $Id: dump.rb 98 2012-04-07 03:52:11Z kimu_shu $
#================================================================================

# 必要なファイルのリスト(サフィックス含む)
DUMPS = %w[sequence.txt mb.txt rl.txt is.txt dq.txt idct.out idct_mid.txt] +
		%w[idct_row.txt idct_col.txt raw.yuv mv.txt mc_out.txt] +
		%w[parser.out isdq.out mc_fetch.out bitstream.txt]

HEADER = <<EOD
//================================================================================
// m2v_dec_eval - データダンプ
// Do not edit this file. This file was generated by dump.rb.
//================================================================================

EOD

puts("generating dump.c ...")
open("dump.c", "w") {|c|
	c.print(HEADER)
	c.print(<<EOD)
#include <string.h>
#include <stdarg.h>
#include "dump.h"

int dump_enable;
EOD
	DUMPS.each {|d|
		c.puts("FILE* dump_#{d.split(".").first};")
	}
	c.print(<<EOD)

int dump_init(const char* dir)
{
	dump_enable = 0;
	if(!dir) return 1;	// 指定が無い場合はダンプ無し

	char path[256];
	strcpy(path, dir);
	char* fn = path + strlen(path);
	if(fn[-1] != '/') *(fn++) = '/';

EOD
	DUMPS.each {|d|
		c.print(<<EOD)
	strcpy(fn, "#{d}");
	if(!(dump_#{d.split(".").first} = fopen(path, "wb")))
	{
		printf("\\nError: Cannot open '%s' for writing!\\n", fn);
		return 0;
	}
EOD
	}

	c.print(<<EOD)

	return 1;
}

void dump_start()
{
	dump_enable = 1;
}

void dump_finish()
{
EOD
	DUMPS.each {|d|
		d = d.split(".").first
		c.print(<<EOD)
	if(dump_#{d}) { fclose(dump_#{d}); dump_#{d} = NULL; }
EOD
	}
	c.print(<<EOD)
}

void dump(FILE* fp, const char* desc, const char* fmt, ...)
{
	if(!fp || !dump_enable) return;

	va_list args;
	va_start(args, fmt);

	char buf[256];
	vsprintf(buf, fmt, args);

	if(desc && *desc)
		fprintf(fp, "%-*s # %s\\n", 39, buf, desc);
	else
		fprintf(fp, "%s\\n", buf);

	va_end(args);
}

void dumpf(FILE* fp, const char* fmt, ...)
{
	if(!fp || !dump_enable) return;

	va_list args;
	va_start(args, fmt);

	char buf[256];
	vsprintf(buf, fmt, args);
	fprintf(fp, "%s", buf);
	va_end(args);
}

void dumpbin(FILE* fp, const void* data, size_t length)
{
	if(!fp || !dump_enable) return;
	fwrite(data, 1, length, fp);
}

// END OF dump.c

EOD
}

puts("generating dump.h ...")
open("dump.h", "w") {|h|
	h.print(HEADER)
	h.print(<<EOD)
#ifndef _DUMP_H_
#define _DUMP_H_

#include <stdio.h>

// exports
extern int dump_init(const char* dir);
extern void dump_start();
extern void dump_finish();
extern void dump(FILE* fp, const char* desc, const char* fmt, ...);
extern void dumpf(FILE* fp, const char* fmt, ...);
extern void dumpbin(FILE* fp, const void* data, size_t length);

// exported file pointers
EOD
	DUMPS.each {|d|
		h.puts("extern FILE* dump_#{d.split(".").first};")
	}
	h.print(<<EOD)

#endif	/* !_DUMP_H_ */

// END OF dump.h

EOD
}

